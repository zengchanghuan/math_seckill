好，我就只讲整体思路，不上代码 😊

---

## 1. 先把概念拆清楚：三层结构

你可以把整个系统脑补成三层：

1. **题目层（Question）**

   * 真正的“题库”，每道题只存在一次
   * 有唯一 ID：`questionId`
   * 包含：题干、选项 / 填空、答案、解析、难度、知识点标签等
     ➜ **永远不要“重新生成”这层，只能增删改。**

2. **试卷 / 训练配置层（Paper Template）**

   * 类似“某套卷的配置”：

     * 包含哪些题的 ID
     * 哪些是选择填空 Section，哪些是解答题 Section
   * 更像“配方”，不是结果
     ➜ 这层可以复用，比如「高一函数专项训练第1套」。

3. **用户实例层（User Paper Instance）**

   * 某个用户在某个时间点，实际拿到的一套题：

     * 绑定模板 ID（可选）
     * 记录这次出题的题目顺序、Tab 结构、开始时间等
       ➜ **“随机”“生成”只发生在这层，而且只发生一次**。

只要把这三层分清楚，你就能做到：
**题库是稳定的、试卷配置是可复用的、真正需要“生成”的只是每次用户的那份实例。**

---

## 2. “避免反复生成”的核心原则

可以用一句话概括：

> **“只在用户第一次进入某个练习时生成一份实例，以后都复用那份实例。”**

具体体现为：

1. **生成时机只在第一次进入**

   * 用户第一次点某个训练入口（比如“函数专项强化训练”）时：

     * 后台/逻辑根据规则，从题库里选题 → 生成一份题目列表 → 记下来（形成一个 `userPaperInstance`）
   * 后面这个用户再次进入这个训练：

     * 不再重新选题，而是直接拿这次生成的那一份。

2. **实例要有“身份”**

   * 给每次生成的练习一个 ID（类似 `paperInstanceId`）
   * 不管是 App 还是小程序：

     * 本地/服务端都能通过这个 ID 找回同一套题
       ➜ 这样就不会出现“返回上一页又刷新一次，全变成新题”的情况。

3. **客户端优先“读取已有实例”，不要动不动就“生成新实例”**

   * 打开某个训练入口时流程应该是：

     1. 先查有没有旧的实例（本地 / 服务器）
     2. 有 → 直接用
     3. 没有 → 才触发一次“生成”

---

## 3. 怎么做到“练习题尽量不重复”？

这是“跨多次训练”的问题，和“单次不重复”是两个层面。

### 3.1 用户层面的做题记录

无论你将来是后端数据库还是小程序云开发，都可以给每个用户维护一份简单的“做题记录”表，核心字段：

* 用户 ID
* questionId
* 做过几次 / 正确次数
* 最后一次答题时间
* 是否掌握（可选，像简易版“掌握度”）

这份记录的作用：

* 新建训练时，可以从“没做过”或“做得少”的题里优先挑
* 想要复习模式时，可以从“错得多 / 间隔很久没做的题”里挑

### 3.2 出题策略示例（逻辑层面）

当用户点击“新的一套训练”时，可以这样设计策略：

1. 先获取题库中**符合条件**（比如“函数 + 高一 + 中等难度”）的所有题
2. 从中筛掉：

   * 最近几天刚做过的题
   * 或者做过次数太多的题
3. 如果还不够题数，再从“做过但掌握率不高”的题里补一点
4. 只要这套题生成成功，就记录成一个新的 `userPaperInstance`，以后不再重生成这套

这样用户看起来就是：

* “新题训练”里大部分都是没见过的题
* “复习/错题本模式”里则是**刻意重复**，但用户心理预期是合理的

---

## 4. 客户端（App & 小程序）应该怎么配合？

这里不讲代码，只讲流程设计。

### 4.1 进入一个训练入口时的通用流程

无论是现在的 App，还是未来的小程序，大致应该遵循：

1. 用户点击某个训练 / 试卷入口
2. 客户端先问一嘴“有没有现成的用户实例？”

   * 可以是本地缓存，也可以是后台接口
3. 判断：

   * 有 → 拉取那份实例（题目的 ID 列表 + 分 Section）
   * 没有 → 向后台发“创建一次训练”的请求，让后台帮你选题并生成实例
4. 前端只负责展示那份题目列表，不参与“到底选哪些题”的决策

**重点：前端不要自己无脑随机。**
一乱随机就很容易出现你不想要的「反复生成」问题。

### 4.2 选择/填空 vs 解答题两个 Tab 怎么落在实例上

在 `userPaperInstance` 这层，把结构直接存出来：

* sections:

  * section1：选择/填空题的 questionId 列表
  * section2：解答题的 questionId 列表

这样：

* App 展示时：Tab1 渲染 section1，Tab2 渲染 section2
* 小程序展示时：也是 Tab1/Tab2 渲染同样的结构

你以后哪怕换技术栈，只要这个数据结构不变，整个「分 Tab 题型」的设计就不会乱。

---

## 5. 先期 MVP 可以怎么简化？

你现在只是用 App 验证想法，可以先把“后台”假想成“本地逻辑”：

1. 题库存成一个固定的 JSON / 本地数据结构（等价于未来的数据库）
2. 第一次进入某个训练时：

   * 从题库里依据规则挑一组题（逻辑写在本地）
   * 把这次的题目 ID 列表连同 Section 分配存到本地存储
3. 后面再进来，只读本地存储，不再重新随机

等你未来上小程序：

* 把“题库 + 出题逻辑 + 用户做题记录”这块搬到后端 / 云开发
* 小程序只负责：**请求已有实例 + 同步作答结果**
* 思路完全一样，只是从“本地逻辑”换成“服务端逻辑”。

---

## 6. 总结成一个小 checklist 给你

后面你可以对照这个清单来设计：

1. ✅ 所有题目都有唯一 questionId，题库存成独立的一份
2. ✅ 试卷/训练不要直接“随机题目”，而是生成一个 `userPaperInstance`（题目列表 + Section 信息）
3. ✅ 每个训练入口，先查有没有旧实例，有就继续用，没有才生成新的
4. ✅ 维护用户做题记录，用来控制“新题优先，重复题有目的”
5. ✅ 前端（App & 小程序）只负责展示现有实例，不要自己频繁随机生成题目

这样就能基本保证：
**题库不会被“反复生成”，题也不会给用户乱重复，同时还能自然支持你将来迁到微信小程序。**
